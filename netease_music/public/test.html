<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>

    // onclick、onmouseover等等，是元素对象的特殊属性。
    // 给元素对象绑定事件函数，类似于给对象的onclick属性赋值，赋的值是一个function(){} 函数对象
    // 类似于以下写法：
    btn = {
        tagname: 'button',
        onclick: function () {
            this.innerHTML = "我是元素";
        },
        onmouseover: function () {
            console.log('我是鼠标' + this.tagname + '移入函数');
        }
    };

    // 如何调用对象的成员方法呢（就是如何调用元素对象上绑定的某事件函数）？
    btn.onclick();//函数调用。 函数内部的this，是在函数调用时决定的。而不是函数声明时决定的。由于是btn调用onclick绑定的函数。所以这里函数的this就是指向btn。

    //函数声明的两种方式
    //声明方式一：用function关键字声明
    function fn() {

    }

   // 这里的函数名fn，是一个变量，这个变量名叫fn。而在js中，函数是个对象。
     function fn() {
     }

  //  函数声明，就类似于定义一个fn的变量，让这个变量保存指向function(){}


  //  函数对象的地址信息

   /* 工作原理：凡是遇到function关键字
    的函数声明，都会发生函数声明提前，就赋值留在原地。这里发生了以下几件事：
     1.
    变量声明提前：var fn;
    声明一个加fn的变量，创建一个fn的存储空间.这一步做完后再回原地进行变量赋值
    2.
    赋值给变量：将function()
    {
    }
    函数对象赋值给fn变量， 就是让fn指向这个函数对象（只是把函数对象的地址信息赋值给了fn变量，fn里保存的只是指向这个函数的地址信息）*/


    //声明方式二：赋值方式声明
    var myfun = function () {
    }

  /*  工作原理：用赋值方式声明函数，等号后面的函数不会被提前, 仍然留在原地。
     1.
    变量声明提前：var myfun;
    声明一个加myfun的变量，创建一个myfun的存储空间.这一步做完后再回原地进行赋值.
    2.
    创建函数定义，赋值给变量：创建function()
    {
    }
    函数定义，将function()
    {
    }
    函数定义赋值给myfun变量， 就是让myfun指向这个函数对象（只是把函数对象的地址信息赋值给了myfun变量，myfun里保存的只是指向这个函数的地址信息）


   注意事项：var 定义的变量，和用function关键字声明的函数，声明会被提前。

     但是赋值方式声明的函数不会被提前，而是保留在原地（等号后面的函数不会被提前, 仍然留在原地；等号前面的用var
    声明的变量仍会被提前）。*/
     var a = 3;

    function b() {
        console.log('bbbbbbbbbb');
    }

    var c = function () {
        console.log('ccccccccccccccc');

    }

   // 执行步骤：

     var a;
    var b;


    a = 3;
    //把一个函数定义赋值给变量b，让b指向这个function（）{} ，b中保存的是指向这个函数定义的地址信息。 注意，这里并未调用函数
    b = function () {
        console.log('bbbbbbbbbb');
    }


    var c = function () {
        console.log('ccccccccccccccc');
    }


</script>
</body>
</html>